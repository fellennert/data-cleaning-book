# Factors with `forcats`

Factors are used in R to represent categorical data. In the following, I will briefly introduce you to the `forcats` package (nice anagram, Hadley!). Factors are augmented vectors which build upon integers. If you want to learn more about them, consider reading [this paper](https://peerj.com/preprints/3163/).

## Creating a factor

You can create a factor in two manners.

1. Take a character vector and coerce it to a factor

```{r}
library(tidyverse)

parties <- c("AfD", "CDU", "CSU", "FDP", "Greens", "Leftists", "SPD")
parties_fct <- as_factor(parties)

typeof(parties_fct)
```

2. Create it from scratch by providing levels and a vector respectively

```{r}
party_sample <- c(
  sample(parties, 49, replace = TRUE), 
  "CUD"
  )

factor(party_sample, levels = parties)
```

If you want to access the levels, use `levels()`

```{r}
levels(parties_fct)
```

## Some basic operations

I will have a further look into factors using data on the presidential elections in the U.S.

```{r}
election_data <- read_csv("https://www.dropbox.com/s/82xuhcwhv7wh314/pres16results.csv?dl=1") |> 
  drop_na() |> 
  glimpse()
```

Which variables should be converted to factors? -- `county`, `cand`, `st`, `lead`.

```{r}
election_data_w_fct <- election_data |> 
  mutate(county = as_factor(county),
         candidate = as_factor(cand),
         state = as_factor(st),
         lead = as_factor(lead)) |> 
  select(county, candidate, state, pct_report:pct, lead)
```

### Reordering factors

Sometimes you want to reorder factors -- for instance, when you want to create plots. (Note: you will learn more on plots in the next session on data visualization)

```{r}
election_data_w_fct |> 
  group_by(state) |> 
  summarize(sum_votes = sum(votes)) |> 
ggplot(aes(x = sum_votes, y = state)) +
  geom_point()
```

Two orders would make sense: alphabetical and according to their number of votes. `fct_reorder()` takes another variable and orders the factor according to it.

```{r}
election_data_w_fct |>
  group_by(state) |> 
  summarize(sum_votes = sum(votes)) |> 
  mutate(state = fct_reorder(state, sum_votes)) |> 
  ggplot(aes(x = sum_votes, y = state)) +
    geom_point()
```

If you want to have it ordered the other way round, multiply the ordering variable with -1:

```{r}
election_data_w_fct |> 
  group_by(state) |> 
  summarize(sum_votes = sum(votes)) |> 
  mutate(state = fct_reorder(state, sum_votes*(-1))) |> 
  ggplot(aes(x = sum_votes, y = state)) +
    geom_point()
```

You could also achieve this by calling `fct_rev()` afterwards: it reverses the order of the factor.

```{r}
election_data_w_fct |> 
  group_by(state) |> 
  summarize(sum_votes = sum(votes)) |> 
  mutate(state = fct_reorder(state, sum_votes),
         state = fct_rev(state)) |> 
ggplot(aes(x = sum_votes, y = state)) +
  geom_point()
```

If you want to do bar plots, which you can use to depict the frequency of a value, you can order them according to the frequency they appear in using `fct_infreq()`:

```{r}
election_data_w_fct |> 
  mutate(lead = lead |> fct_infreq() |> fct_rev()) |> 
  ggplot(aes(x = lead)) +
    geom_bar()
```

### Modifying levels

Remember the first factor? You need to put some graphs together and decide that you would rather like to use the original German names for the parties. Go for `fct_recode()`.

```{r}
parties_fct_ger <- fct_recode(parties_fct,
  "Buendnis90/Die Gruenen" = "Greens", 
  "Die Linke" = "Leftists"
)
```

Damn, now the levels are not in alphabetical order anymore.

```{r}
levels(parties_fct_ger)
```

In this case, this can be done pretty quickly. Just copy the levels and manipulate the order:

```{r}
parties_fct_ger_alphabetical <- fct_relevel(parties_fct_ger, 
                                            c("AfD", 
                                              "Buendnis90/Die Gruenen", 
                                              "CDU", 
                                              "CSU",
                                              "Die Linke",
                                              "FDP",
                                              "SPD"))
levels(parties_fct_ger_alphabetical)
```

Now you need to write something for someone who is not particular familiar with the political landscape in Germany and rather wants "left," "center," and "right" instead of the party's names. Give `fct_collapse()` a shot -- and feel free to change it if you disagree with my classification.

```{r}
lcr_ger <- fct_collapse(parties_fct,
                        left = c("Leftists", "Greens", "SPD"),
                        centre = c("CDU", "CSU", "FDP"),
                        right = c("AfD")
                        )
```

Another thing you could do -- and this is handy for the election data set -- is collapsing things together according to their frequency of appearance. In the case of the election data set, this might be handy to lump together the candidates into three groups: Donald Trump, Hillary Clinton, and other.

```{r}
election_data_w_fct |> 
  mutate(candidate = fct_lump(candidate, n = 2))
```

The problem here is that Gary Johnson appears as often as the two other candidates (have you ever heard of him?). Hence, `fct_lump()` cannot decide which levels to lump together. However, it has saved me a couple lines of code:

```{r}
election_data_w_fct |> 
  mutate(candidate = fct_lump(candidate, n = 2) |> 
           fct_recode("Other" = "Gary Johnson"))
```

## Further links

* The chapter in [R4DS](https://r4ds.had.co.nz/factors.html)
* If you want to learn more about factors, consider reading [this paper](https://peerj.com/preprints/3163/)
* Another [tutorial](https://www.r-bloggers.com/2020/06/working-with-factors-in-r-tutorial-forcats-package/)

## Dates

In the script about data import you have learned about how to parse dates: for `parse_date()`, dates have to be formatted in a certain standard or you need to provide it with one. This is often tedious. That's where the `lubridate` package jumps in: it provides you with parsing functions that are more handy. They all take a character vector and the function's name is related to the order of the date's components. The functions recognize non-digit separators and are, therefore, most of the time a hassle-free way to parse dates.

```{r}
library(lubridate)

ymd("2000-02-29")
ymd("2000 02 29")
dmy("29.02.2000")
```

There is also a function for quarters:

```{r}
yq("2000: Q3")
```

## Date-times

They also have date-time equivalents:

```{r}
ymd_hms("2000-02-29 14:00:00")
mdy_hm("02-29-2000 10.04")
dmy_h("29.02.2000 10")
```

## Further handy things

```{r}
today()
now()
```

## Manipulating dates

### Components

You can also extract singular components from dates using the following functions:

```{r}
example_datetime <- ymd_hms("2000-02-29 14:00:00")

date(example_datetime)
year(example_datetime)
month(example_datetime)
day(example_datetime)
hour(example_datetime)
minute(example_datetime)
second(example_datetime)
week(example_datetime)
quarter(example_datetime)
semester(example_datetime)
am(example_datetime)
pm(example_datetime)
leap_year(example_datetime)
```

### Rounding

Sometimes you will also want to round dates -- e.g., if you count observations per month or something similar.

```{r}
floor_date(example_datetime, unit = "month")
floor_date(example_datetime, unit = "3 months")

round_date(example_datetime, unit = "year")

ceiling_date(example_datetime, unit = "day")

rollback(example_datetime, roll_to_first = FALSE, preserve_hms = TRUE)
rollback(example_datetime, roll_to_first = TRUE, preserve_hms = FALSE)
```

## Time zones

Dealing with time zones is tedious. By default, R sets the time zone of every date you provide it with to UTC (Coordinated Universal Time). However, sometimes you need to change it -- e.g., when you deal with flight data. `lubridate` provides you with some handy functions for doing so. Generally speaking, you will not often work with them.

First, you need to know which arguments you can provide the functions with -- or, put differently, the names of the time zones. 

```{r}
head(OlsonNames()) # wrapped it with head() because it's 593 in total
```

If you want to set a new time zone to a date-object -- hence, 2 o'clock UTC becomes 2 o'clock CET -- use `force_tz()`:

```{r}
force_tz(example_datetime, tzone = "CET")
```

If you want to transform your date-time object to a new time zone, preserving its time -- for example, for appointments all around the world -- use `with_tz()`. If you use the aforementioned `now()` function, `lubridate` will use your computer's time zone:

```{r}
with_tz(now(), tzone = "US/Eastern")
```

## Periods, durations, intervals

You will also want to do some calculations based on the dates and times you have parsed. 

### Periods

A period can be created using a pluralized name of a time unit.

```{r}
months(3) + days(5)
```

Another way of doing so -- which is suited for automation -- is `period()`:

```{r}
period(num = 5, unit = "years")
```

You can also set multiple arguments:

```{r}
period(num = 1:5, units = c("years", "months", "days", "hours", "minutes"))
```

### Durations

Durations can be used to model physical processes. They are stored in seconds and can be created by prefixing the name of a period:

```{r}
dweeks(x = 1)
```

Again, there's a constructor function:

```{r}
duration(num = 1:5, units = c("years", "months", "days", "hours", "minutes"))
```

How long do I have to wait until Christmas?

```{r}
ymd("2022-12-24")-today()
```

### Intervals

Intervals can be created by using the `interval()` function or by using the `%--%` operator.

```{r}
interval(today(), ymd("2020-12-24"))
today() %--% ymd("2020-12-24")
```

You can divide an interval by a duration to determine its physical length:

```{r}
christmas <- today() %--% ymd("2020-12-24")
christmas/ddays(x = 1)
```

You can divide an interval by a period to determine its implied length in clock time:

```{r}
christmas/days(x = 1)
```

If you want to know its length in seconds, you can also do `int_length()`:

```{r}
int_length(christmas)
```

There are also some other things you can do with intervals:

Does the start of the winter semester fall within the period between now and Christmas?

```{r}
ymd("2020-11-04") %within% interval(today(), ymd("2020-12-24"))
```

Reverse the direction of the interval:

```{r}
int_flip(interval(today(), ymd("2020-12-24")))
```

You can also shift an interval:

today until Christmas --> tomorrow until December 25:

```{r}
int_shift(christmas, by = days(1))
```

## Further links

* The [lubridate page](https://lubridate.tidyverse.org) which also contains a cheatsheet
* The [R4DS chapter](https://r4ds.had.co.nz/dates-and-times.html)